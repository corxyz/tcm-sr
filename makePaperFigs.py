import sys
import numpy as np
import util, plotting, pachinko_sim, bias_var, pstopSim

#################################################
#  GLOBAL SETTINGS, CONSTANTS & HYPERPARAMETERS
#################################################

np.set_printoptions(threshold=sys.maxsize)

fig_to_make = [3]         # specify figure number
panel_to_make = '3b'         # specify panel letter
# NOTE: Panels of figure 5 are generated by learn_sr.py and limitedSamps.py
#       Schematics in figure 1 are hand-drawn
#       Choice plots are all generated using choice.py
#       All other figures (rest of 1, 2-4, 6) are generated using this script

n_row, n_col = 10, 9        # number of rows and columns of the Plinko board
n_rew = 15                  # number of rewards
s0 = (0,4)                  # action (state to drop the ball)
add_absorb_state = True       # whether to add an absorbing state at the end of the board or not

T = pachinko_sim.init_trans(n_row, n_col, add_absorb_state=add_absorb_state)   # one-step transition matrix
MTF_id = np.identity(n_row * n_col + add_absorb_state)                  # MTF matrix of TCM

n_exp = 10                  # number of experiments (boards)
n_trial = 1000              # number of trials per experiment (trajectory if beta > 0; not used if beta = 0)
n_samp = 1000             # number of i.i.d. samples per trial (only used if beta = 0)
max_samp = 100            # maximum number of samples per trial (only used if beta > 0)
pstops = [0.05, 0.5, 1.0]   # interruption probabilities (p_stop)
gammas = [0, 0.5]           # discount factors (equivalent to rho_enc in CMR)

########################################
#  MAIN ROUTINE
########################################

if 1 in fig_to_make:
  # Figure 1(A): Schematic of Pachinko
  if '1a' in panel_to_make:
    maze = pachinko_sim.init_maze(n_row, n_col, n_rew, userandom=True)
    plotting.plot_maze(maze)
  # Figure 1(B): transition matrices & SR
  if '1b' in panel_to_make:
    M_ext = util.get_sr(T, gamma=0.9, extra_trans_on_sr=True)
    n_state = n_row * n_col
    state_idx = np.arange(0,n_state).reshape((n_row, n_col))    # state indices
    plotting.plot_T_SR(n_row, n_col, state_idx, s0, T, M_ext, add_absorb_state=add_absorb_state)
  
  # Figure 1(C): simuated recency and contiguity curves
  if '1c' in panel_to_make:
    rho_1c, beta_1c = 0.9, 0.1
    M_1c = util.get_sr(T, gamma=0.5, extra_trans_on_sr=True)
    plotting.plot_recency(n_exp*n_samp, n_row, n_col, s0, M_1c[:n_row*n_col, :n_row*n_col], 
                          MFC=MTF_id[:n_row*n_col, :n_row*n_col], rho=0.3, beta=0.7, add_absorb_state=False)
    _, _, _, _, samped_row = bias_var.run_sim(1000, 10, n_row, n_col, n_rew, s0, M_1c, 
                                          MFC=MTF_id, rho=rho_1c, beta=beta_1c)
    plotting.plot_crp_iid(samped_row, n_row, maxDist=9, omitZero=True)
  
  # Figure 1(D): TCM-SR schematics (not included) 

if 2 in fig_to_make:
  rho, beta = 1, 0
  # Figure 2(A)
  if '2a' in panel_to_make:
    maze = pachinko_sim.init_maze(n_row, n_col, n_rew, userandom=True)
    n_state = maze.size
    state_idx = np.arange(0,n_state).reshape(maze.shape)    # state indices
    stim = np.identity(n_state + add_absorb_state)
    gamma = 0
    M_ext = util.get_sr(T, gamma=gamma, extra_trans_on_sr=True)
    samp_idx = bias_var.draw_samp(s0, maze, state_idx, stim, M_ext, 4, rho=rho, beta=beta)
    gamma = 0.5
    M_ext = util.get_sr(T, gamma=gamma, extra_trans_on_sr=True)
    samp_idx = bias_var.draw_samp(s0, maze, state_idx, stim, M_ext, 4, rho=rho, beta=beta)
    
  # Figure 2(B)
  vtrues, vsamps, samped_rowList = [], [], []
  for gamma in gammas:
    M_ext = util.get_sr(T, gamma=gamma, extra_trans_on_sr=True)
    vtrue, vsamp, _, samped_row = bias_var.run_sim(n_exp, n_samp, n_row, n_col, n_rew, 
                                                  s0, M_ext, MFC=MTF_id,
                                                  rho=rho, beta=beta)
    vtrues.append(vtrue)
    vsamps.append(vsamp)
    samped_rowList.append(samped_row)

  if '2b' in panel_to_make:
    plotting.plot_sample_dist_iid(n_row, n_exp, samped_rowList, gammas=gammas)

if 3 in fig_to_make:
  rho, beta = 0, 1
  vsamp_list, vtrue_list, eGammas = [], [], []

  gamma = gammas[0]
  M_ext = util.get_sr(T, gamma=gamma, extra_trans_on_sr=True)

  if '3a' in panel_to_make:
    # Figure 3(A)
    maze = pachinko_sim.init_maze(n_row, n_col, n_rew, userandom=True)
    n_state = maze.size
    state_idx = np.arange(0,n_state).reshape(maze.shape)
    stim = np.identity(n_state + add_absorb_state)
    samp_idx = bias_var.draw_samp(s0, maze, state_idx, stim, M_ext, 4, rho=rho, beta=beta, incl_last_samp=True)

  samped_row = np.negative(np.ones((len(pstops), n_exp, n_trial, max_samp), dtype=int))
  vsamps = np.zeros((len(pstops), n_exp, n_trial, max_samp))
  vtrues = np.zeros((len(pstops), n_exp))
  veffect = np.zeros((len(pstops), n_exp))
  predicted_gammas = np.array([pstop * gamma + (1-pstop) for pstop in pstops])
  for i, pstop in enumerate(pstops):
    eGamma = predicted_gammas[i]
    M_effect = util.get_sr(T, gamma=eGamma, extra_trans_on_sr=True)
    samped, vsamp, vtrue, ve = pstopSim.run_sim(n_exp, n_trial, n_row, n_col, n_rew, s0, M_ext, M_effect, pstop,
                                                MFC=MTF_id, max_samp=max_samp, rho=rho, beta=beta)
    samped_row[i,:,:,:] = samped
    vsamps[i,:,:,:] = vsamp
    vtrues[i,:] = vtrue
    veffect[i,:] = ve
    plotting.plot_crp_noniid(samped, n_row, omitZero=True)
  vsamp_list.append(vsamps)
  vtrue_list.append(veffect)
  eGammas.append(predicted_gammas)

  if '3b' in panel_to_make:
    # Figure 3(B) - effective gamma version
    plotting.plot_sample_dist_noniid(samped_row, n_row, n_exp, pstops, predicted_gammas)

  gamma = gammas[1]
  M_ext = util.get_sr(T, gamma=gamma, extra_trans_on_sr=True)

  if '3c' in panel_to_make:
    # Figure 3(C)
    maze = pachinko_sim.init_maze(n_row, n_col, n_rew, userandom=True)
    n_state = maze.size
    state_idx = np.arange(0,n_state).reshape(maze.shape)
    stim = np.identity(n_state + add_absorb_state)
    samp_idx = bias_var.draw_samp(s0, maze, state_idx, stim, M_ext, 4, rho=rho, beta=beta, incl_last_samp=True)

  samped_row = np.negative(np.ones((len(pstops), n_exp, n_trial, max_samp), dtype=int))
  vsamps = np.zeros((len(pstops), n_exp, n_trial, max_samp))
  vtrues = np.zeros((len(pstops), n_exp))
  veffect = np.zeros((len(pstops), n_exp))
  predicted_gammas = np.array([pstop * gamma + (1-pstop) for pstop in pstops])
  for i, pstop in enumerate(pstops):
    eGamma = predicted_gammas[i]
    M_effect = util.get_sr(T, gamma=eGamma, extra_trans_on_sr=True)
    samped, vsamp, vtrue, ve = pstopSim.run_sim(n_exp, n_trial, n_row, n_col, n_rew, s0, M_ext, M_effect, pstop,
                                                MFC=MTF_id, max_samp=max_samp, rho=rho, beta=beta)
    samped_row[i,:,:,:] = samped
    vsamps[i,:,:,:] = vsamp
    vtrues[i,:] = vtrue
    veffect[i,:] = ve
    plotting.plot_crp_noniid(samped, n_row, maxDist=5, omitZero=True)
  vsamp_list.append(vsamps)
  vtrue_list.append(veffect)
  eGammas.append(predicted_gammas)

  if '3d' in panel_to_make:
    # Figure 3(D) - effective gamma version
    plotting.plot_sample_dist_noniid(samped_row, n_row, n_exp, pstops, predicted_gammas)

  # Figure 3(E)
  if '3e' in panel_to_make:
    plotting.plot_val_est_noniid(max_samp, n_trial, vtrue_list, vsamp_list, beta, gammas, eGammas)
  
if 4 in fig_to_make:
  rho, beta = 0.75, 0.25
  vsamp_list, vtrue_list, eGammas = [], [], []

  gamma = gammas[0]
  M_ext = util.get_sr(T, gamma=gamma, extra_trans_on_sr=True)

  if '4a' in panel_to_make:
    # Figure 4(A)
    maze = pachinko_sim.init_maze(n_row, n_col, n_rew, userandom=True)
    n_state = maze.size
    state_idx = np.arange(0,n_state).reshape(maze.shape)
    stim = np.identity(n_state + add_absorb_state)
    samp_idx = bias_var.draw_samp(s0, maze, state_idx, stim, M_ext, 4, rho=rho, beta=beta, incl_last_samp=True)

  samped_row = np.negative(np.ones((len(pstops), n_exp, n_trial, max_samp), dtype=int))
  vsamps = np.zeros((len(pstops), n_exp, n_trial, max_samp))
  vtrues = np.zeros((len(pstops), n_exp))
  veffect = np.zeros((len(pstops), n_exp))
  predicted_gammas = np.array([pstop * gamma + (1-pstop) for pstop in pstops])
  for i, pstop in enumerate(pstops):
    eGamma = predicted_gammas[i]
    M_effect = util.get_sr(T, gamma=eGamma, extra_trans_on_sr=True)
    samped, vsamp, vtrue, ve = pstopSim.run_sim(n_exp, n_trial, n_row, n_col, n_rew, s0, M_ext, M_effect, pstop,
                                                MFC=MTF_id, max_samp=max_samp, rho=rho, beta=beta)
    samped_row[i,:,:,:] = samped
    vsamps[i,:,:,:] = vsamp
    vtrues[i,:] = vtrue
    veffect[i,:] = ve
  vsamp_list.append(vsamps)
  vtrue_list.append(veffect)
  eGammas.append(predicted_gammas)

  if '4b' in panel_to_make:
    # Figure 4(B) - effective gamma version
    plotting.plot_sample_dist_noniid(samped_row, n_row, n_exp, pstops, predicted_gammas, legend_in=True)

  gamma = gammas[1]
  M_ext = util.get_sr(T, gamma=gamma, extra_trans_on_sr=True)

  if '4c' in panel_to_make:
    # Figure 4(C)
    maze = pachinko_sim.init_maze(n_row, n_col, n_rew, userandom=True)
    n_state = maze.size
    state_idx = np.arange(0,n_state).reshape(maze.shape)
    stim = np.identity(n_state + add_absorb_state)
    samp_idx = bias_var.draw_samp(s0, maze, state_idx, stim, M_ext, 4, rho=rho, beta=beta, incl_last_samp=True)

  samped_row = np.negative(np.ones((len(pstops), n_exp, n_trial, max_samp), dtype=int))
  vsamps = np.zeros((len(pstops), n_exp, n_trial, max_samp))
  vtrues = np.zeros((len(pstops), n_exp))
  veffect = np.zeros((len(pstops), n_exp))
  predicted_gammas = np.array([pstop * gamma + (1-pstop) for pstop in pstops])
  for i, pstop in enumerate(pstops):
    eGamma = predicted_gammas[i]
    M_effect = util.get_sr(T, gamma=eGamma, extra_trans_on_sr=True)
    samped, vsamp, vtrue, ve = pstopSim.run_sim(n_exp, n_trial, n_row, n_col, n_rew, s0, M_ext, M_effect, pstop,
                                                MFC=MTF_id, max_samp=max_samp, rho=rho, beta=beta)
    samped_row[i,:,:,:] = samped
    vsamps[i,:,:,:] = vsamp
    vtrues[i,:] = vtrue
    veffect[i,:] = ve
  vsamp_list.append(vsamps)
  vtrue_list.append(veffect)
  eGammas.append(predicted_gammas)

  if '4d' in panel_to_make:
    # Figure 4(D) - effective gamma version
    plotting.plot_sample_dist_noniid(samped_row, n_row, n_exp, pstops, predicted_gammas, legend_in=True)

  # Figure 4(E)
  if '4e' in panel_to_make:
    plotting.plot_val_est_noniid(max_samp, n_trial, vtrue_list, vsamp_list, beta, gammas, eGammas)
  
if 6 in fig_to_make:
  rho, beta = 0, 1
  pstops = [0.2, 0.5, 1]
  T = pachinko_sim.init_trans(n_row, n_col, add_absorb_state=add_absorb_state)
  T_rev = pachinko_sim.init_trans(n_row, n_col, add_absorb_state=add_absorb_state, reversible=True)
  vsamp_list, vtrue_list, eGammas = [], [], []
  vrefList = []

  gamma = gammas[1]
  M = util.get_sr(T, gamma=gamma, extra_trans_on_sr=False)
  M_ext = util.get_sr(T, gamma=gamma, extra_trans_on_sr=True)

  if '6a' in panel_to_make:
    # Figure 6(A)
    maze = pachinko_sim.init_maze(n_row, n_col, n_rew, userandom=True)
    n_state = maze.size
    state_idx = np.arange(0,n_state).reshape(maze.shape)
    stim = np.identity(n_state + add_absorb_state)
    samp_idx = bias_var.draw_samp((4,4), maze, state_idx, stim, M_ext, 4, rho=rho, beta=beta, MFC=M, incl_last_samp=True)

  samped_row = np.negative(np.ones((len(pstops), n_exp, n_trial, max_samp), dtype=int))
  vsamps = np.zeros((len(pstops), n_exp, n_trial, max_samp))
  vtrues = np.zeros((len(pstops), n_exp))
  veffect = np.zeros((len(pstops), n_exp))
  predicted_gammas = np.array([pstop * gamma + (1-pstop) for pstop in pstops])
  for i, pstop in enumerate(pstops):
    eGamma = predicted_gammas[i]
    M_rev = util.get_sr(T_rev, gamma=eGamma, extra_trans_on_sr=True)
    samped, vsamp, vtrue, ve = pstopSim.run_sim(n_exp, n_trial, n_row, n_col, n_rew, s0, M_ext, M_rev, pstop, reachable=s0,
                                                rand_rew=True, MFC=M_ext, max_samp=max_samp, rho=rho, beta=beta)
    samped_row[i,:,:,:] = samped
    vsamps[i,:,:,:] = vsamp
    vtrues[i,:] = vtrue
    veffect[i,:] = ve
  vsamp_list.append(vsamps)
  vtrue_list.append(veffect)
  vrefList.append(vtrues)
  eGammas.append(predicted_gammas)

  # Figure 6(D)
  if '6d' in panel_to_make:
    plotting.plot_est_err_dist(vtrue_list[0], vsamp_list[0], eGammas[0], plot_fitted=True, title=r'$M^{SC}=M$')
    plotting.plot_est_err_dist(vtrue_list[0], vrefList[0], eGammas[0], plot_fitted=True, is_sample=False, title=r'$M^{SC}=I$')

  # Figure 6(E)
  if '6e' in panel_to_make:
    plotting.plot_val_est_noniid(max_samp, n_trial, vtrue_list, vsamp_list, beta, gammas, eGammas)
